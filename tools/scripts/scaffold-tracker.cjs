#!/usr/bin/env node
/**
 * Phase 3 – Application Tracker scaffolding (idempotent)
 * - Shared types: shared/types/src/lib/tracker.ts (+ index.ts re-export)
 * - Prisma: ensure ApplicationStatus enum + Application model (no destructive ops)
 * - API (NestJS + tRPC): tracker.router.ts + root.ts wiring
 * - Web: /web/src/app/tracker/page.tsx (Kanban stub using shared/trpc client)
 * - Tests: api tracker specs + web test stub
 *
 * Safe to re-run. Only writes/patches where needed.
 */
const fs = require('fs');
const path = require('path');
const cp = require('child_process');

const ROOT = process.cwd();
const W = (p, c) => {
  const a = path.join(ROOT, p);
  if (fs.existsSync(a)) {
    const cur = fs.readFileSync(a, 'utf8');
    if (cur === c) return console.log('= up-to-date', p);
    // only overwrite if content meaningfully differs and file is generated by us
    fs.writeFileSync(a, c, 'utf8');
    console.log('~ updated ', p);
  } else {
    fs.mkdirSync(path.dirname(a), { recursive: true });
    fs.writeFileSync(a, c, 'utf8');
    console.log('+ wrote   ', p);
  }
};
const A = (p, line) => {
  const a = path.join(ROOT, p);
  let t = fs.existsSync(a) ? fs.readFileSync(a, 'utf8') : '';
  if (!t.includes(line)) {
    if (t && !t.endsWith('\n')) t += '\n';
    t += line + '\n';
    fs.mkdirSync(path.dirname(a), { recursive: true });
    fs.writeFileSync(a, t, 'utf8');
    console.log('~ appended', p, '→', line.trim());
  } else {
    console.log('= present ', p, '→', line.trim());
  }
};
const run = (cmd) => cp.execSync(cmd, { stdio: 'inherit' });

/* 1) Shared types (Nx layout you restored earlier has shared/types) */
const TYPES_TRACKER = `// Shared tracker types
import { z } from 'zod';

export const ApplicationStatus = z.enum(['APPLIED','INTERVIEWING','OFFER','REJECTED']);
export type ApplicationStatus = z.infer<typeof ApplicationStatus>;

export const ApplicationItem = z.object({
  id: z.string(),
  title: z.string(),
  company: z.string(),
  status: ApplicationStatus,
  url: z.string().optional(),
  tags: z.array(z.string()).default([]),
  deadline: z.string().datetime().optional(),
  notes: z.string().optional(),
  resumeVersion: z.string().optional(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  userId: z.string(),
});
export type ApplicationItem = z.infer<typeof ApplicationItem>;

export const CreateApplicationInput = ApplicationItem.omit({ id: true, createdAt: true, updatedAt: true });
export type CreateApplicationInput = z.infer<typeof CreateApplicationInput>;

export const UpdateApplicationInput = ApplicationItem.partial().extend({ id: z.string() });
export type UpdateApplicationInput = z.infer<typeof UpdateApplicationInput>;
`;
W('shared/types/src/lib/tracker.ts', TYPES_TRACKER);

// re-export from shared/types/src/index.ts
A('shared/types/src/index.ts', `export * from './lib/tracker';`);

/* 2) Prisma schema ensure */
const PRISMA_SCHEMA_PATHS = [
  'shared/prisma/schema.prisma', // preferred in your repo
  'prisma/schema.prisma',
].filter((p) => fs.existsSync(path.join(ROOT, p)));

if (PRISMA_SCHEMA_PATHS.length) {
  const p = PRISMA_SCHEMA_PATHS[0];
  const abs = path.join(ROOT, p);
  let s = fs.readFileSync(abs, 'utf8');
  let changed = false;

  if (!/enum\s+ApplicationStatus\s*\{/.test(s)) {
    s += `

enum ApplicationStatus {
  APPLIED
  INTERVIEWING
  OFFER
  REJECTED
}
`;
    changed = true;
  }
  if (!/model\s+Application\s*\{/.test(s)) {
    s += `

model Application {
  id            String            @id @default(cuid())
  title         String
  company       String
  status        ApplicationStatus @default(APPLIED)
  url           String?
  tags          String[]          @default([])
  deadline      DateTime?
  notes         String?
  resumeVersion String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  userId        String

  @@index([userId])
}
`;
    changed = true;
  }
  if (changed) {
    fs.writeFileSync(abs, s, 'utf8');
    console.log('~ updated Prisma schema:', p);
  } else {
    console.log('= Prisma schema ok:', p);
  }
} else {
  console.log(
    '! Prisma schema not found (looked in shared/prisma/schema.prisma or prisma/schema.prisma). Skipping Prisma edits.'
  );
}

/* 3) API: tRPC router + root wiring (NestJS + tRPC pattern) */
const TRACKER_ROUTER = `import { z } from 'zod';
import { publicProcedure, router } from '../trpc';
import { ApplicationItem, CreateApplicationInput, UpdateApplicationInput } from '@careeros/types';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export const trackerRouter = router({
  getApplications: publicProcedure
    .input(z.object({ userId: z.string() }))
    .output(z.array(ApplicationItem))
    .query(async ({ input }) => {
      const apps = await prisma.application.findMany({
        where: { userId: input.userId },
        orderBy: [{ updatedAt: 'desc' }],
      });
      return apps.map(a => ({
        ...a,
        createdAt: a.createdAt.toISOString(),
        updatedAt: a.updatedAt.toISOString(),
        deadline: a.deadline ? a.deadline.toISOString() : undefined,
      }));
    }),

  createApplication: publicProcedure
    .input(CreateApplicationInput)
    .output(ApplicationItem)
    .mutation(async ({ input }) => {
      const created = await prisma.application.create({ data: {
        ...input,
        deadline: input.deadline ? new Date(input.deadline) : null,
      }});
      return {
        ...created,
        createdAt: created.createdAt.toISOString(),
        updatedAt: created.updatedAt.toISOString(),
        deadline: created.deadline ? created.deadline.toISOString() : undefined,
      };
    }),

  updateApplication: publicProcedure
    .input(UpdateApplicationInput)
    .output(ApplicationItem)
    .mutation(async ({ input }) => {
      const { id, ...rest } = input;
      const updated = await prisma.application.update({
        where: { id },
        data: {
          ...rest,
          deadline: rest.deadline ? new Date(rest.deadline) : undefined,
        }
      });
      return {
        ...updated,
        createdAt: updated.createdAt.toISOString(),
        updatedAt: updated.updatedAt.toISOString(),
        deadline: updated.deadline ? updated.deadline.toISOString() : undefined,
      };
    }),

  deleteApplication: publicProcedure
    .input(z.object({ id: z.string() }))
    .output(z.object({ id: z.string() }))
    .mutation(async ({ input }) => {
      await prisma.application.delete({ where: { id: input.id }});
      return { id: input.id };
    }),
});
`;

const TRPC_BOOTSTRAP = `// Minimal tRPC bootstrap for NestJS/Nx layouts
import { initTRPC } from '@trpc/server';
export const t = initTRPC.create();
export const router = t.router;
export const publicProcedure = t.procedure;
`;

const API_DIR = fs.existsSync(path.join(ROOT, 'api'))
  ? 'api'
  : fs.existsSync(path.join(ROOT, 'apps/api'))
  ? 'apps/api'
  : null;

if (API_DIR) {
  // ensure trpc kernel exists
  W(path.join(API_DIR, 'src/trpc/trpc.ts'), TRPC_BOOTSTRAP);
  // tracker router
  W(path.join(API_DIR, 'src/trpc/routers/tracker.router.ts'), TRACKER_ROUTER);

  // root router: create or patch
  const ROOT_ROUTER_P = path.join(API_DIR, 'src/trpc/root.ts');
  let rootContent = fs.existsSync(ROOT_ROUTER_P)
    ? fs.readFileSync(ROOT_ROUTER_P, 'utf8')
    : `import { router } from './trpc';
export const appRouter = router({});
export type AppRouter = typeof appRouter;
`;

  if (!/trackerRouter/.test(rootContent)) {
    if (!/from\s+['"]\.\/routers\/tracker\.router['"]/.test(rootContent)) {
      rootContent =
        `import { trackerRouter } from './routers/tracker.router';\n` +
        rootContent;
    }
    rootContent = rootContent.replace(/router\(\{([\s\S]*?)\}\)/m, (m, g1) => {
      const items = g1.trim();
      const withTracker = items
        ? items + `,\n  tracker: trackerRouter`
        : `tracker: trackerRouter`;
      return `router({\n  ${withTracker}\n})`;
    });
    if (!/export type AppRouter = typeof appRouter;/.test(rootContent)) {
      rootContent += `\nexport type AppRouter = typeof appRouter;\n`;
    }
    W(path.join(API_DIR, 'src/trpc/root.ts'), rootContent);
  } else {
    console.log('= tracker already wired in root router');
  }

  // API tests (jest) – light stubs using our existing prisma mock approach
  const API_SPEC = `import { trackerRouter } from '../routers/tracker.router';

describe('tracker router', () => {
  it('exposes CRUD procedures', () => {
    expect(typeof trackerRouter).toBe('object');
    expect(Object.keys(trackerRouter._def.procedures)).toEqual(
      expect.arrayContaining(['getApplications','createApplication','updateApplication','deleteApplication'])
    );
  });
});
`;
  W(path.join(API_DIR, 'src/trpc/__tests__/tracker.router.spec.ts'), API_SPEC);
} else {
  console.log('! API app not found (api/ or apps/api/). Skipping API router.');
}

/* 4) Web page using shared trpc client  */
const WEB_PAGE = `'use client';

import React from 'react';
import Link from 'next/link';
import { trpc } from '@careeros/trpc';
import { ApplicationItem } from '@careeros/types';

function Column({ title, items }: { title: string; items: ApplicationItem[] }) {
  return (
    <div style={{ flex: 1, minWidth: 240, padding: 12, border: '1px solid #e5e7eb', borderRadius: 8 }}>
      <h3 style={{ marginBottom: 8 }}>{title}</h3>
      <div style={{ display: 'grid', gap: 8 }}>
        {items.map((a) => (
          <div key={a.id} style={{ padding: 12, border: '1px solid #e5e7eb', borderRadius: 8, background: '#fff' }}>
            <div style={{ fontWeight: 600 }}>{a.title}</div>
            <div style={{ color: '#6b7280' }}>{a.company}</div>
            {a.url && <a href={a.url} target="_blank" rel="noreferrer">Job link</a>}
            {a.tags?.length ? <div style={{ marginTop: 6, fontSize: 12, color: '#6b7280' }}>#{a.tags.join(' #')}</div> : null}
          </div>
        ))}
      </div>
    </div>
  );
}

export default function TrackerPage() {
  // NOTE: replace the userId with the actual logged-in user (from your auth context)
  const userId = 'demo-user';
  const { data } = trpc.tracker.getApplications.useQuery({ userId });

  const apps = data ?? [];
  const grouped = {
    APPLIED: apps.filter(a => a.status === 'APPLIED'),
    INTERVIEWING: apps.filter(a => a.status === 'INTERVIEWING'),
    OFFER: apps.filter(a => a.status === 'OFFER'),
    REJECTED: apps.filter(a => a.status === 'REJECTED'),
  };

  return (
    <main style={{ padding: 24 }}>
      <h1 style={{ fontSize: 24, fontWeight: 700, marginBottom: 16 }}>Application Tracker</h1>
      <div style={{ display: 'flex', gap: 12, alignItems: 'flex-start' }}>
        <Column title="Applied" items={grouped.APPLIED} />
        <Column title="Interviewing" items={grouped.INTERVIEWING} />
        <Column title="Offer" items={grouped.OFFER} />
        <Column title="Rejected" items={grouped.REJECTED} />
      </div>
      <div style={{ marginTop: 16 }}>
        <Link href="/">← Back</Link>
      </div>
    </main>
  );
}
`;
W('web/src/app/tracker/page.tsx', WEB_PAGE);

// Web test stub
const WEB_SPEC = `import { render, screen } from '@testing-library/react';
import TrackerPage from '../src/app/tracker/page';

jest.mock('@careeros/trpc', () => ({
  trpc: {
    tracker: {
      getApplications: {
        useQuery: () => ({ data: [] })
      }
    }
  }
}));

test('renders tracker heading', () => {
  render(<TrackerPage />);
  expect(screen.getByText(/Application Tracker/i)).toBeInTheDocument();
});
`;
W('web/specs/tracker.spec.tsx', WEB_SPEC);

/* 5) Post steps: prisma fmt/validate/generate (safe) */
try {
  if (fs.existsSync(path.join(ROOT, 'shared/prisma/schema.prisma'))) {
    run('pnpm -w prisma format --schema shared/prisma/schema.prisma');
    run('pnpm -w prisma validate --schema shared/prisma/schema.prisma');
    run('pnpm --filter @careeros/prisma run prisma:generate');
  } else if (fs.existsSync(path.join(ROOT, 'prisma/schema.prisma'))) {
    run('pnpm -w prisma format --schema prisma/schema.prisma');
    run('pnpm -w prisma validate --schema prisma/schema.prisma');
    run('pnpm -w prisma generate --schema prisma/schema.prisma');
  } else {
    console.log('! Skipping prisma steps (schema not found).');
  }
} catch (e) {
  console.warn(
    '! Prisma steps partially failed (non-fatal for scaffolding).',
    e.message || e
  );
}

console.log('\n[done] Tracker module scaffold complete ✅');
console.log(
  '- Types: shared/types/src/lib/tracker.ts (re-exported in index.ts)'
);
console.log(
  '- API  :',
  API_DIR ? `${API_DIR}/src/trpc/routers/tracker.router.ts` : '(skipped)'
);
console.log('- Web  : web/src/app/tracker/page.tsx');
console.log('- Tests: API + Web stubs added');
